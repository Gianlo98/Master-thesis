@InProceedings{Wettel2011,
  author    = {Wettel, Richard and Lanza, Michele and Robbes, Romain},
  booktitle = {2011 33rd International Conference on Software Engineering (ICSE)},
  title     = {Software systems as cities: a controlled experiment},
  year      = {2011},
  pages     = {551-560},
  doi       = {10.1145/1985793.1985868},
}

@INPROCEEDINGS{4658085,  author={Boccuzzo, Sandro and Gall, Harald C.},  booktitle={2008 IEEE International Conference on Software Maintenance},   title={Software visualization with audio supported cognitive glyphs},   year={2008},  volume={},  number={},  pages={366-375},  doi={10.1109/ICSM.2008.4658085}}

@inproceedings{10.1145/1056018.1056027,
author = {Pinzger, Martin and Gall, Harald and Fischer, Michael and Lanza, Michele},
title = {Visualizing Multiple Evolution Metrics},
year = {2005},
isbn = {1595930736},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1056018.1056027},
doi = {10.1145/1056018.1056027},
abstract = {Observing the evolution of very large software systems needs the analysis of large complex data models and visualization of condensed views on the system. For visualization software metrics have been used to compute such condensed views. However, current techniques concentrate on visualizing data of one particular release providing only insufficient support for visualizing data of several releases.In this paper we present the RelVis visualization approach that concentrates on providing integrated condensed graphical views on source code and release history data of up to n releases. Measures of metrics of source code entities and relationships are composed in Kiviat diagrams as annual rings. Diagrams highlight the good and bad times of an entity and facilitate the identification of entities and relationships with critical trends. They represent potential refactoring candidates that should be addressed first before further evolving the system. The paper provides needed background information and evaluation of the approach with a large open source software project.},
booktitle = {Proceedings of the 2005 ACM Symposium on Software Visualization},
pages = {67–75},
numpages = {9},
keywords = {evolution metrics, software evolution analysis, Kiviat, software visualization},
location = {St. Louis, Missouri},
series = {SoftVis '05}
}

@INPROCEEDINGS{8900965,
  author={Alexandru, Carol V. and Proksch, Sebastian and Behnamghader, Pooyan and Gall, Harald C.},
  booktitle={2019 Working Conference on Software Visualization (VISSOFT)}, 
  title={Evo-Clocks: Software Evolution at a Glance}, 
  year={2019},
  volume={},
  number={},
  pages={12-22},
  doi={10.1109/VISSOFT.2019.00010}}

  
  
  
  
  
  
  
  @INPROCEEDINGS{7329727,
  author={Kapec, P. and Brndiarová, G. and Gloger, M. and Marák, J.},
  booktitle={2015 IEEE 19th International Conference on Intelligent Engineering Systems (INES)}, 
  title={Visual analysis of software systems in virtual and augmented reality}, 
  year={2015},
  volume={},
  number={},
  pages={307-312},
  doi={10.1109/INES.2015.7329727}}

  
  @INPROCEEDINGS{7780168,
  author={Schneider, Teseo and Tymchuk, Yuriy and Salgado, Ronie and Bergel, Alexandre},
  booktitle={2016 IEEE Working Conference on Software Visualization (VISSOFT)}, 
  title={CuboidMatrix: Exploring Dynamic Structural Connections in Software Components Using Space-Time Cube}, 
  year={2016},
  volume={},
  number={},
  pages={116-125},
  doi={10.1109/VISSOFT.2016.17}}

@InProceedings{Merino2018,
  author = {Merino, Leonel and Bergel, Alexandre and Nierstrasz, Oscar},
  title  = {Overcoming Issues of {3D} Software Visualization through Immersive Augmented Reality},
  year   = {2018},
  month  = {09},
  doi    = {10.1109/VISSOFT.2018.00014},
}

@Article{VonMayrhauser1995,
  author  = {Von Mayrhauser, A. and Vans, A.M.},
  journal = {Computer},
  title   = {Program comprehension during software maintenance and evolution},
  year    = {1995},
  number  = {8},
  pages   = {44-55},
  volume  = {28},
  doi     = {10.1109/2.402076},
}

@InBook{Stasko2008,
  author = {Fekete, Jean-Daniel and van Wijk, Jarke and Stasko, John and North, Chris},
  pages  = {1-18},
  title  = {The Value of Information Visualization},
  year   = {2008},
  isbn   = {978-3-540-70955-8},
  month  = {07},
  volume = {4950},
  doi    = {10.1007/978-3-540-70956-5_1},
}

@InProceedings{Lanza2001,
  author    = {Lanza, Michele},
  booktitle = {Proceedings of the 4th International Workshop on Principles of Software Evolution},
  title     = {The Evolution Matrix: Recovering Software Evolution Using Software Visualization Techniques},
  year      = {2001},
  address   = {New York, NY, USA},
  pages     = {37–42},
  publisher = {Association for Computing Machinery},
  series    = {IWPSE '01},
  abstract  = {One of the major problems in software evolution is coping with the complexity which stems from the huge amount of data that must be considered. The current approaches to deal with that problem all aim at a reduction of complexity and a filtering of the relevant information. In this paper we propose an approach based on a combination of software visualization and software metrics which we have already successfully applied in the field of software reverse engineering. Using this approach we discuss a simple and effective way to visualize the evolution of software systems which helps to recover the evolution of object oriented software systems.},
  doi       = {10.1145/602461.602467},
  isbn      = {1581135084},
  keywords  = {software visualization, reverse engineering, software metrics},
  location  = {Vienna, Austria},
  numpages  = {6},
  url       = {https://doi.org/10.1145/602461.602467},
}

@Article{Chuah1998,
  author  = {Chuah, M.C. and Eick, S.G.},
  journal = {IEEE Computer Graphics and Applications},
  title   = {Information rich glyphs for software management data},
  year    = {1998},
  number  = {4},
  pages   = {24-29},
  volume  = {18},
  doi     = {10.1109/38.689658},
}

@Book{Dijkstra1971,
  author    = {Dijkstra, E.W. and Technische Hogeschool Eindhoven},
  publisher = {Techn. Hogeschool},
  title     = {EWD316: A Short Introduction to the Art of Programming},
  year      = {1971},
  url       = {https://books.google.ch/books?id=E\_XhswEACAAJ},
}

@InProceedings{Haibt1959,
  author    = {Haibt, Lois M.},
  booktitle = {Papers Presented at the the March 3-5, 1959, Western Joint Computer Conference},
  title     = {A Program to Draw Multilevel Flow Charts},
  year      = {1959},
  address   = {New York, NY, USA},
  pages     = {131–137},
  publisher = {Association for Computing Machinery},
  series    = {IRE-AIEE-ACM '59 (Western)},
  abstract  = {The preparation of a program for a digital computer is not complete when a list of instructions has been written. It still must be determined that the instructions do the required job, and if necessary the instructions must be changed until they do. Also a description of the program should be written for others who may want to understand the program. A useful tool for the last purpose is a graphical outline of the program---a flow chart.},
  doi       = {10.1145/1457838.1457861},
  isbn      = {9781450378659},
  location  = {San Francisco, California},
  numpages  = {7},
  url       = {https://doi.org/10.1145/1457838.1457861},
}

@Article{Knuth1963,
  author     = {Knuth, Donald E.},
  journal    = {Commun. ACM},
  title      = {Computer-Drawn Flowcharts},
  year       = {1963},
  issn       = {0001-0782},
  month      = {sep},
  number     = {9},
  pages      = {555–563},
  volume     = {6},
  abstract   = {To meet the need for improved documentation of written computer programs, a simple system for effective communication is presented, which has shown great promise. The programmer describes his program in a simple format, and the computer prepares flow charts and other cross-referenced listings from this input. The description can be kept up-to-date easily, and the final output clearly explains the original program. The system has also proved to be a valuable debugging and coding aid.},
  address    = {New York, NY, USA},
  doi        = {10.1145/367593.367620},
  issue_date = {Sept. 1963},
  numpages   = {9},
  publisher  = {Association for Computing Machinery},
  url        = {https://doi.org/10.1145/367593.367620},
}

@Article{Nassi1973,
  author     = {Nassi, I. and Shneiderman, B.},
  journal    = {SIGPLAN Not.},
  title      = {Flowchart Techniques for Structured Programming},
  year       = {1973},
  issn       = {0362-1340},
  month      = {aug},
  number     = {8},
  pages      = {12–26},
  volume     = {8},
  abstract   = {With the advent of structured programming and GOTO-less programming a method is needed to model computation in simply ordered structures, each representing a complete thought possibly defined in terms of other thoughts as yet undefined. A model is needed which prevents unrestricted transfers of control and has a control structure closer to languages amenable to structured programming. We present an attempt at such a model.},
  address    = {New York, NY, USA},
  doi        = {10.1145/953349.953350},
  issue_date = {August 1973},
  numpages   = {15},
  publisher  = {Association for Computing Machinery},
  url        = {https://doi.org/10.1145/953349.953350},
}

@Article{Baecker1998,
  author    = {Baecker, Ronald},
  journal   = {Software visualization: Programming as a multimedia experience},
  title     = {Sorting out sorting: A case study of software visualization for teaching computer science},
  year      = {1998},
  pages     = {369--381},
  volume    = {1},
  publisher = {The MIT Press, Cambridge, MA},
}

@Article{Hueras1977,
  author     = {Hueras, Jon and Ledgard, Henry},
  journal    = {SIGPLAN Not.},
  title      = {An Automatic Formatting Program for PASCAL},
  year       = {1977},
  issn       = {0362-1340},
  month      = {jul},
  number     = {7},
  pages      = {82–84},
  volume     = {12},
  address    = {New York, NY, USA},
  doi        = {10.1145/954639.954645},
  issue_date = {July 1977},
  numpages   = {3},
  publisher  = {Association for Computing Machinery},
  url        = {https://doi.org/10.1145/954639.954645},
}

@Article{Brown1988,
  author     = {Brown, Marc H.},
  journal    = {Computer},
  title      = {Exploring Algorithms Using Balsa-II},
  year       = {1988},
  issn       = {0018-9162},
  month      = {may},
  number     = {5},
  pages      = {14–36},
  volume     = {21},
  abstract   = {The use of the Balsa-II algorithm animation environment to investigate the dynamic behavior of programs is discussed. Balsa-II is examined first from a user's perspective and then from a programmer's perspective. Some related systems are briefly considered.},
  address    = {Washington, DC, USA},
  doi        = {10.1109/2.56},
  issue_date = {May 1988},
  numpages   = {23},
  publisher  = {IEEE Computer Society Press},
  url        = {https://doi.org/10.1109/2.56},
}

@Article{Waters1983,
  author     = {Waters, Richard C.},
  journal    = {ACM Trans. Program. Lang. Syst.},
  title      = {User Format Control in a LISP Prettyprinter},
  year       = {1983},
  issn       = {0164-0925},
  month      = {oct},
  number     = {4},
  pages      = {513–531},
  volume     = {5},
  address    = {New York, NY, USA},
  doi        = {10.1145/69575.357225},
  issue_date = {Oct. 1983},
  numpages   = {19},
  publisher  = {Association for Computing Machinery},
  url        = {https://doi.org/10.1145/69575.357225},
}

@InProceedings{Mueller1988,
  author    = {M\"{u}ller, H. A. and Klashinsky, K.},
  booktitle = {Proceedings of the 10th International Conference on Software Engineering},
  title     = {Rigi-A System for Programming-in-the-Large},
  year      = {1988},
  address   = {Washington, DC, USA},
  pages     = {80–86},
  publisher = {IEEE Computer Society Press},
  series    = {ICSE '88},
  abstract  = {This paper describes Rigi, a model and a tool for programming-in-the-large. Rigi uses a graph model and abstraction mechanisms to structure and represent the information accumulated during the development process. The objects and relationships of the graph model represent system components and their dependencies. The objects can be arranged in aggregation and generalization hierarchies. The Rigi editor assists the designers, programmers, integrators, and maintainers in defining, manipulating, exploring, and understanding, the structure of large, integrated, evolving software systems. Rigi was designed to address three of the most difficult problems in the area of programming-in-the-large: the mastery of the structural complexity of large software systems, the effective presentation of development information, and the definition of procedures for checking and maintaining the completeness, consistency, and traceability of system descriptions. Thus, the major objective of Rigi is to effectively represent and manipulate the building blocks of a software system and their myriad dependencies, thereby aiding the development phases of the project.},
  isbn      = {0897912586},
  location  = {Singapore},
  numpages  = {7},
}

@Article{Eick1992,
  author     = {Eick, Stephen G. and Steffen, Joseph L. and Sumner, Eric E.},
  journal    = {IEEE Trans. Softw. Eng.},
  title      = {Seesoft-A Tool for Visualizing Line Oriented Software Statistics},
  year       = {1992},
  issn       = {0098-5589},
  month      = {nov},
  number     = {11},
  pages      = {957–968},
  volume     = {18},
  abstract   = {The Seesoft software visualization system allows one to analyze up to 50000 lines of code simultaneously by mapping each line of code into a thin row. The color of each row indicates a statistic of interest, e.g., red rows are those most recently changed, and blue are those least recently changed. Seesoft displays data derived from a variety of sources, such as version control systems that track the age, programmer, and purpose of the code (e.g., control ISDN lamps, fix bug in call forwarding); static analyses, (e.g., locations where functions are called); and dynamic analyses (e.g., profiling). By means of direct manipulation and high interaction graphics, the user can manipulate this reduced representation of the code in order to find interesting patterns. Further insight is obtained by using additional windows to display the actual code. Potential applications for Seesoft include discovery, project management, code tuning, and analysis of development methodologies.},
  doi        = {10.1109/32.177365},
  issue_date = {November 1992},
  keywords   = {code tuning, call forwarding, development methodologies, discovery, software tools, Seesoft, line oriented software statistics, data visualisation, tool, ISDN lamps, configuration management, static analyses, high interaction graphics, direct manipulation, project management, version control systems, software visualization system, dynamic analyses},
  numpages   = {12},
  publisher  = {IEEE Press},
  url        = {https://doi.org/10.1109/32.177365},
}

@InProceedings{DePauw1993,
  author    = {De Pauw, Wim and Helm, Richard and Kimelman, Doug and Vlissides, John},
  booktitle = {Proceedings of the Eighth Annual Conference on Object-Oriented Programming Systems, Languages, and Applications},
  title     = {Visualizing the Behavior of Object-Oriented Systems},
  year      = {1993},
  address   = {New York, NY, USA},
  pages     = {326–337},
  publisher = {Association for Computing Machinery},
  series    = {OOPSLA '93},
  doi       = {10.1145/165854.165919},
  isbn      = {0897915879},
  location  = {Washington, D.C., USA},
  numpages  = {12},
  url       = {https://doi.org/10.1145/165854.165919},
}

@InProceedings{Young1998,
  author    = {Young, P. and Munro, M.},
  booktitle = {Proceedings. 6th International Workshop on Program Comprehension. IWPC'98 (Cat. No.98TB100242)},
  title     = {Visualising software in virtual reality},
  year      = {1998},
  pages     = {19-26},
  doi       = {10.1109/WPC.1998.693276},
}

@Article{,
}

@Comment{jabref-meta: databaseType:bibtex;}
