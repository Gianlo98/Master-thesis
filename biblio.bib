


@inproceedings{10.1145/1056018.1056027,
	abstract = {Observing the evolution of very large software systems needs the analysis of large complex data models and visualization of condensed views on the system. For visualization software metrics have been used to compute such condensed views. However, current techniques concentrate on visualizing data of one particular release providing only insufficient support for visualizing data of several releases.In this paper we present the RelVis visualization approach that concentrates on providing integrated condensed graphical views on source code and release history data of up to n releases. Measures of metrics of source code entities and relationships are composed in Kiviat diagrams as annual rings. Diagrams highlight the good and bad times of an entity and facilitate the identification of entities and relationships with critical trends. They represent potential refactoring candidates that should be addressed first before further evolving the system. The paper provides needed background information and evaluation of the approach with a large open source software project.},
	address = {New York, NY, USA},
	author = {Pinzger, Martin and Gall, Harald and Fischer, Michael and Lanza, Michele},
	booktitle = {Proceedings of the 2005 ACM Symposium on Software Visualization},
	doi = {10.1145/1056018.1056027},
	isbn = {1595930736},
	keywords = {evolution metrics, software evolution analysis, Kiviat, software visualization},
	location = {St. Louis, Missouri},
	numpages = {9},
	pages = {67--75},
	publisher = {Association for Computing Machinery},
	series = {SoftVis '05},
	title = {Visualizing Multiple Evolution Metrics},
	url = {https://doi.org/10.1145/1056018.1056027},
	year = {2005},
	bdsk-url-1 = {https://doi.org/10.1145/1056018.1056027}}

@inproceedings{4658085,
	author = {Boccuzzo, Sandro and Gall, Harald C.},
	booktitle = {2008 IEEE International Conference on Software Maintenance},
	doi = {10.1109/ICSM.2008.4658085},
	pages = {366-375},
	title = {Software visualization with audio supported cognitive glyphs},
	year = {2008},
	bdsk-url-1 = {https://doi.org/10.1109/ICSM.2008.4658085}}

@inproceedings{7329727,
	author = {Kapec, P. and Brndiarov{\'a}, G. and Gloger, M. and Mar{\'a}k, J.},
	booktitle = {2015 IEEE 19th International Conference on Intelligent Engineering Systems (INES)},
	doi = {10.1109/INES.2015.7329727},
	pages = {307-312},
	title = {Visual analysis of software systems in virtual and augmented reality},
	year = {2015},
	bdsk-url-1 = {https://doi.org/10.1109/INES.2015.7329727}}

@inproceedings{7780168,
	author = {Schneider, Teseo and Tymchuk, Yuriy and Salgado, Ronie and Bergel, Alexandre},
	booktitle = {2016 IEEE Working Conference on Software Visualization (VISSOFT)},
	doi = {10.1109/VISSOFT.2016.17},
	pages = {116-125},
	title = {CuboidMatrix: Exploring Dynamic Structural Connections in Software Components Using Space-Time Cube},
	year = {2016},
	bdsk-url-1 = {https://doi.org/10.1109/VISSOFT.2016.17}}

@inproceedings{8900965,
	author = {Alexandru, Carol V. and Proksch, Sebastian and Behnamghader, Pooyan and Gall, Harald C.},
	booktitle = {2019 Working Conference on Software Visualization (VISSOFT)},
	doi = {10.1109/VISSOFT.2019.00010},
	pages = {12-22},
	title = {Evo-Clocks: Software Evolution at a Glance},
	year = {2019},
	bdsk-url-1 = {https://doi.org/10.1109/VISSOFT.2019.00010}}

@inproceedings{Alexandru2019,
	author = {Alexandru, Carol V. and Proksch, Sebastian and Behnamghader, Pooyan and Gall, Harald C.},
	booktitle = {2019 Working Conference on Software Visualization (VISSOFT)},
	doi = {10.1109/VISSOFT.2019.00010},
	pages = {12-22},
	title = {Evo-Clocks: Software Evolution at a Glance},
	year = {2019},
	bdsk-url-1 = {https://doi.org/10.1109/VISSOFT.2019.00010}}

@inproceedings{Alty1995,
	author = {Alty, James L},
	booktitle = {People and Computers X: Proceedings of the HCI'95 Conference},
	organization = {Cambridge University Press},
	pages = {409},
	title = {Computer-Human Communication?},
	volume = {10},
	year = {1995}}

@article{Baecker1998,
	author = {Baecker, Ronald},
	journal = {Software visualization: Programming as a multimedia experience},
	pages = {369--381},
	publisher = {The MIT Press, Cambridge, MA},
	title = {Sorting out sorting: A case study of software visualization for teaching computer science},
	volume = {1},
	year = {1998}}

@inproceedings{Boccuzzo2009,
	author = {Boccuzzo, Sandro and Gall, Harald C.},
	booktitle = {2009 IEEE 31st International Conference on Software Engineering},
	doi = {10.1109/ICSE.2009.5070558},
	pages = {571-574},
	title = {CocoViz with ambient audio software exploration},
	year = {2009},
	bdsk-url-1 = {https://doi.org/10.1109/ICSE.2009.5070558}}

@article{Brown1988,
	abstract = {The use of the Balsa-II algorithm animation environment to investigate the dynamic behavior of programs is discussed. Balsa-II is examined first from a user's perspective and then from a programmer's perspective. Some related systems are briefly considered.},
	address = {Washington, DC, USA},
	author = {Brown, Marc H.},
	doi = {10.1109/2.56},
	issn = {0018-9162},
	issue_date = {May 1988},
	journal = {Computer},
	month = {may},
	number = {5},
	numpages = {23},
	pages = {14--36},
	publisher = {IEEE Computer Society Press},
	title = {Exploring Algorithms Using Balsa-II},
	url = {https://doi.org/10.1109/2.56},
	volume = {21},
	year = {1988},
	bdsk-url-1 = {https://doi.org/10.1109/2.56}}

@inproceedings{Butler1993,
	address = {USA},
	author = {Butler, David M. and Almond, James C. and Bergeron, R. Daniel and Brodlie, Ken W. and Haber, Robert B.},
	booktitle = {Proceedings of the 4th Conference on Visualization '93},
	isbn = {0818639407},
	location = {San Jose, California},
	numpages = {6},
	pages = {337--342},
	publisher = {IEEE Computer Society},
	series = {VIS '93},
	title = {Visualization Reference Models},
	year = {1993}}

@article{Chuah1998,
	author = {Chuah, M.C. and Eick, S.G.},
	doi = {10.1109/38.689658},
	journal = {IEEE Computer Graphics and Applications},
	number = {4},
	pages = {24-29},
	title = {Information rich glyphs for software management data},
	volume = {18},
	year = {1998},
	bdsk-url-1 = {https://doi.org/10.1109/38.689658}}

@article{Clem2021,
	abstract = {The Semantic Code team at GitHub builds and operates a suite of technologies that power symbolic code navigation on github.com. We learned that scale is about adoption, user behavior, incremental improvement, and utility. Static analysis in particular is difficult to scale with respect to human behavior; we often think of complex analysis tools working to find potentially problematic patterns in code and then trying to convince the humans to fix them. Our approach took a different tack: use basic analysis techniques to quickly put information that augments our ability to understand programs in front of everyone reading code on GitHub with zero configuration required and almost immediate availability after code changes.},
	address = {New York, NY, USA},
	author = {Clem, Timothy and Thomson, Patrick},
	doi = {10.1145/3487019.3487022},
	issn = {1542-7730},
	issue_date = {July-August 2021},
	journal = {Queue},
	month = {aug},
	number = {4},
	numpages = {26},
	pages = {42--67},
	publisher = {Association for Computing Machinery},
	title = {Static Analysis at GitHub: An Experience Report},
	url = {https://doi.org/10.1145/3487019.3487022},
	volume = {19},
	year = {2021},
	bdsk-url-1 = {https://doi.org/10.1145/3487019.3487022}}

@article{Corbi1989,
	author = {Corbi, T. A.},
	doi = {10.1147/sj.282.0294},
	journal = {IBM Systems Journal},
	number = {2},
	pages = {294-306},
	title = {Program understanding: Challenge for the 1990s},
	volume = {28},
	year = {1989},
	bdsk-url-1 = {https://doi.org/10.1147/sj.282.0294}}

@inproceedings{DAmbros2006,
	author = {D'Ambros, M. and Lanza, M.},
	booktitle = {Conference on Software Maintenance and Reengineering (CSMR'06)},
	doi = {10.1109/CSMR.2006.51},
	pages = {10 pp.-238},
	title = {Software bugs and evolution: a visual approach to uncover their relationship},
	year = {2006},
	bdsk-url-1 = {https://doi.org/10.1109/CSMR.2006.51}}

@inproceedings{DAmbros2006a,
	abstract = {In software evolution research logical coupling has extensively been used to recover the hidden dependencies between source code artifacts. They would otherwise go lost because of the file-based nature of current versioning systems. Previous research has dealt with low-level couplings between files, leading to an explosion of data to be analyzed, or has abstracted the logical couplings to module level, leading to a loss of detailed information. In this paper we propose a visualization-based approach which integrates both file-level and module-level logical coupling information. This not only facilitates an in-depth analysis of the logical couplings at all granularity levels, it also leads to a precise characterization of the system modules in terms of their logical coupling dependencies.},
	address = {New York, NY, USA},
	author = {D'Ambros, Marco and Lanza, Michele and Lungu, Mircea},
	booktitle = {Proceedings of the 2006 International Workshop on Mining Software Repositories},
	doi = {10.1145/1137983.1137992},
	isbn = {1595933972},
	keywords = {visualization, evolution, logical coupling},
	location = {Shanghai, China},
	numpages = {7},
	pages = {26--32},
	publisher = {Association for Computing Machinery},
	series = {MSR '06},
	title = {The Evolution Radar: Visualizing Integrated Logical Coupling Information},
	url = {https://doi.org/10.1145/1137983.1137992},
	year = {2006},
	bdsk-url-1 = {https://doi.org/10.1145/1137983.1137992}}

@book{Davis1995,
	abstract = {From the PrefaceIf software engineering is really an engineering discipline, it is the intelligent application of proven principles, techniques, languages, and tools to the cost-effective creation and maintenance of software that satisfies users' needs. This book is the first collection of software engineering principles ever written in one volume. A principle is a basic truth, rule, or assumption about software engineering that holds regardless of the technique, tool, or language selected. With few exceptions, the principles published here are not original. They have been extracted from the writings of many software engineering practitioners and researchers. These individuals have been unselfish enough to share their experiences, ideas, and wisdom with all of us. I make no claim that these 201 principles are mutually exclusive. Unlike Boehm's seven "basic" software engineering principles, a combination of some of these principles may imply another. I also make no claim that these 201 principles are 100 percent compatible. The adages, "Absence makes the heart grow fonder" and "Out of sight, out of mind" are each true, and each can be applied to life, but they cannot both be used to justify the same decision. The principles contained in this volume are all valid, and they can all be used to improve software engineering, but it may be impossible to apply some combinations of them on any one project.Manny Lehman [LEH80] has stated eloquently why principles underlying software engineering are inherently different from principles underlying other areas of human exploration. He states there is no reason to expect such principles to have the same "precision and predictability of [say] the laws of physics." The reason for this is that, unlike physics or biology, the process of software development is "managed and implemented by people; thus in the long term [its behavior should] be expected to be unpredictable, dependent on the judgments, whims, and actions of [people]." On the other hand, software does seem to exhibit many regular and predictable traits [LEH80]. These lead to many basic principles that can be enumerated and used by inexperienced and experienced software engineers and managers to enhance the quality of both the software engineering process and software products.The purpose of this book is to present in one volume the principles of software engineering as a reference guide. It is aimed at three classes of readers:1. Software engineers and managers. In this book you can find out what is good and what is not. If you are new at software engineering or software management, here is a place to find out what you need to know.2. Students of software engineering. For students, there are two primary uses of this book. First, here are the basic, nondogmatic tenets that every software engineer should know. Second, the references in these pages point to some of the best papers and books ever written on software engineering. If you do nothing other than read the items referenced, this book will have been successful, and you will have been exposed to a wealth of knowledge.3. Software researchers. Researchers may often find it difficult to find the original source of an idea. I have provided references to publications that reflect either the original source or an alternative, excellent work that refers to the original source.I sincerely hope that everybody who buys this book attempts to read as many of the referenced works as possible. My brief description of the principle is intended to be friendly, easy-to-read, and insightful. But for real appreciation you need to read the referenced works. These works are not necessarily the original source of the idea (although in many cases they are). Nor is the given principle necessarily a primary point of the reference. In every case, however, the referenced work contains a wealth of helpful background, insight, justification, backup data, or information related to the principle.In summary, this book should be the first place for you to look up any software engineering idea. However, this is a book of principles, not techniques, languages, or tools. You will not find out how to use any techniques, languages, or tools which the principles described here transcend. Furthermore, this book tries to avoid all fads, good or bad! For the most part, fads are popular for three to ten years, then lose favor. The underlying principles that might be behind a fad can be found in this volume, but not the fad itself. Thus, for example, you won't see any reference to object-orientation per se here, but you will find many references to the principles underlying object-orientation, such as encapsulation.The principles are organized into general categories to aid in finding them and to aid in relating similar principles. These categories correspond to primary phases of software development (that is, requirements, design, etc.) and to other critical "support" activities, such as management, product assurance, and so on, as shown in Fig. P-1.REFERENCES[BOE83] Boehm, B., "Seven Basic Principles of Software Engineering," Journal of Systems and Software, 3, 1 (March 1983), pp. 3-24. [LEH80] Lehman, M., "On Understanding Laws, Evolution, and Conservation in the Large-Program Life Cycle," Journal of Systems and Software, 1, 3 (July 1980), pp. 213-221. [ROY70] Royce, W., "Managing the Development of Large Software Systems," WESCON '70, 1970;},
	address = {USA},
	author = {Davis, Alan M.},
	isbn = {0070158401},
	publisher = {McGraw-Hill, Inc.},
	title = {201 Principles of Software Development},
	year = {1995}}

@inproceedings{DePauw1993,
	address = {New York, NY, USA},
	author = {De Pauw, Wim and Helm, Richard and Kimelman, Doug and Vlissides, John},
	booktitle = {Proceedings of the Eighth Annual Conference on Object-Oriented Programming Systems, Languages, and Applications},
	doi = {10.1145/165854.165919},
	isbn = {0897915879},
	location = {Washington, D.C., USA},
	numpages = {12},
	pages = {326--337},
	publisher = {Association for Computing Machinery},
	series = {OOPSLA '93},
	title = {Visualizing the Behavior of Object-Oriented Systems},
	url = {https://doi.org/10.1145/165854.165919},
	year = {1993},
	bdsk-url-1 = {https://doi.org/10.1145/165854.165919}}

@inproceedings{DiGiano1993,
	abstract = {Even for the programmer, computer software can be a mysterious black box. But what if the programmer were able to give the box a good shake and listen to things rattle inside? Are there tools like the doctor's stethoscope that can help programmers listen to the heartbeat of their software? These are the kinds of questions we decided to explore by building LogoMedia, a sound-enhanced programming environment. LogoMedia supports the ability to associate non-speech audio with program events while the code is being developed. These associations cause subsequent test runs of the program to generate and manipulate sounds which can aid in the comprehension and analysis of the program's behavior.},
	address = {New York, NY, USA},
	author = {DiGiano, Christopher J. and Baecker, Ronald M. and Owen, Russell N.},
	booktitle = {Proceedings of the INTERACT '93 and CHI '93 Conference on Human Factors in Computing Systems},
	doi = {10.1145/169059.169229},
	isbn = {0897915755},
	keywords = {software visualization, program auralization, non-speech audio, programming environments},
	location = {Amsterdam, The Netherlands},
	numpages = {2},
	pages = {301--302},
	publisher = {Association for Computing Machinery},
	series = {CHI '93},
	title = {LogoMedia: A Sound-Enhanced Programming Environment for Monitoring Program Behavior},
	url = {https://doi.org/10.1145/169059.169229},
	year = {1993},
	bdsk-url-1 = {https://doi.org/10.1145/169059.169229}}

@book{Dijkstra1971,
	author = {Dijkstra, E.W. and Technische Hogeschool Eindhoven},
	publisher = {Techn. Hogeschool},
	title = {EWD316: A Short Introduction to the Art of Programming},
	url = {https://books.google.ch/books?id=E\_XhswEACAAJ},
	year = {1971},
	bdsk-url-1 = {https://books.google.ch/books?id=E%5C_XhswEACAAJ}}

@article{Eick1992,
	abstract = {The Seesoft software visualization system allows one to analyze up to 50000 lines of code simultaneously by mapping each line of code into a thin row. The color of each row indicates a statistic of interest, e.g., red rows are those most recently changed, and blue are those least recently changed. Seesoft displays data derived from a variety of sources, such as version control systems that track the age, programmer, and purpose of the code (e.g., control ISDN lamps, fix bug in call forwarding); static analyses, (e.g., locations where functions are called); and dynamic analyses (e.g., profiling). By means of direct manipulation and high interaction graphics, the user can manipulate this reduced representation of the code in order to find interesting patterns. Further insight is obtained by using additional windows to display the actual code. Potential applications for Seesoft include discovery, project management, code tuning, and analysis of development methodologies.},
	author = {Eick, Stephen G. and Steffen, Joseph L. and Sumner, Eric E.},
	doi = {10.1109/32.177365},
	issn = {0098-5589},
	issue_date = {November 1992},
	journal = {IEEE Trans. Softw. Eng.},
	keywords = {code tuning, call forwarding, development methodologies, discovery, software tools, Seesoft, line oriented software statistics, data visualisation, tool, ISDN lamps, configuration management, static analyses, high interaction graphics, direct manipulation, project management, version control systems, software visualization system, dynamic analyses},
	month = {nov},
	number = {11},
	numpages = {12},
	pages = {957--968},
	publisher = {IEEE Press},
	title = {Seesoft-A Tool for Visualizing Line Oriented Software Statistics},
	url = {https://doi.org/10.1109/32.177365},
	volume = {18},
	year = {1992},
	bdsk-url-1 = {https://doi.org/10.1109/32.177365}}

@inproceedings{Ens2014,
	author = {Ens, Barrett and Rea, Daniel and Shpaner, Roiy and Hemmati, Hadi and Young, James E. and Irani, Pourang},
	booktitle = {2014 Second IEEE Working Conference on Software Visualization},
	doi = {10.1109/VISSOFT.2014.28},
	pages = {117-126},
	title = {ChronoTwigger: A Visual Analytics Tool for Understanding Source and Test Co-evolution},
	year = {2014},
	bdsk-url-1 = {https://doi.org/10.1109/VISSOFT.2014.28}}

@article{Erlikh2000,
	author = {Erlikh, L.},
	doi = {10.1109/6294.846201},
	journal = {IT Professional},
	number = {3},
	pages = {17-23},
	title = {Leveraging legacy system dollars for e-business},
	volume = {2},
	year = {2000},
	bdsk-url-1 = {https://doi.org/10.1109/6294.846201}}

@article{Girba2005,
	author = {Tudor G{\^{\i}}rba and St{\'{e}}phane Ducasse},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	biburl = {https://dblp.org/rec/journals/smr/GirbaD06.bib},
	doi = {10.1002/smr.325},
	journal = {J. Softw. Maintenance Res. Pract.},
	number = {3},
	pages = {207--236},
	timestamp = {Wed, 20 May 2020 21:25:29 +0200},
	title = {Modeling history to analyze software evolution},
	url = {https://doi.org/10.1002/smr.325},
	volume = {18},
	year = {2006},
	bdsk-url-1 = {https://doi.org/10.1002/smr.325}}

@article{Greene2017,
	author = {Greene, Gillian J and Esterhuizen, Marvin and Fischer, Bernd},
	journal = {Information and Software Technology},
	pages = {223--241},
	publisher = {Elsevier},
	title = {Visualizing and exploring software version control repositories using interactive tag clouds over formal concept lattices},
	volume = {87},
	year = {2017}}

@inproceedings{Haibt1959,
	abstract = {The preparation of a program for a digital computer is not complete when a list of instructions has been written. It still must be determined that the instructions do the required job, and if necessary the instructions must be changed until they do. Also a description of the program should be written for others who may want to understand the program. A useful tool for the last purpose is a graphical outline of the program---a flow chart.},
	address = {New York, NY, USA},
	author = {Haibt, Lois M.},
	booktitle = {Papers Presented at the the March 3-5, 1959, Western Joint Computer Conference},
	doi = {10.1145/1457838.1457861},
	isbn = {9781450378659},
	location = {San Francisco, California},
	numpages = {7},
	pages = {131--137},
	publisher = {Association for Computing Machinery},
	series = {IRE-AIEE-ACM '59 (Western)},
	title = {A Program to Draw Multilevel Flow Charts},
	url = {https://doi.org/10.1145/1457838.1457861},
	year = {1959},
	bdsk-url-1 = {https://doi.org/10.1145/1457838.1457861}}

@article{Hatton2017,
	author = {Hatton, Les and Spinellis, Diomidis and van Genuchten, Michiel},
	doi = {10.1002/smr.1847},
	journal = {Journal of Software: Evolution and Process},
	month = {02},
	pages = {e1847},
	title = {The long-term growth rate of evolving software: Empirical results and implications: Software Growth Rate},
	volume = {29},
	year = {2017},
	bdsk-url-1 = {https://doi.org/10.1002/smr.1847}}

@article{Hueras1977,
	address = {New York, NY, USA},
	author = {Hueras, Jon and Ledgard, Henry},
	doi = {10.1145/954639.954645},
	issn = {0362-1340},
	issue_date = {July 1977},
	journal = {SIGPLAN Not.},
	month = {jul},
	number = {7},
	numpages = {3},
	pages = {82--84},
	publisher = {Association for Computing Machinery},
	title = {An Automatic Formatting Program for PASCAL},
	url = {https://doi.org/10.1145/954639.954645},
	volume = {12},
	year = {1977},
	bdsk-url-1 = {https://doi.org/10.1145/954639.954645}}

@inproceedings{Jackson1992,
	author = {Jackson, J.A. and Francioni, J.M.},
	booktitle = {Proceedings of the Twenty-Fifth Hawaii International Conference on System Sciences},
	doi = {10.1109/HICSS.1992.183294},
	pages = {218-229 vol.2},
	title = {Aural signatures of parallel programs},
	volume = {ii},
	year = {1992},
	bdsk-url-1 = {https://doi.org/10.1109/HICSS.1992.183294}}

@book{Jacobson1999,
	address = {USA},
	author = {Jacobson, Ivar and Booch, Grady and Rumbaugh, James},
	isbn = {0201571692},
	publisher = {Addison-Wesley Longman Publishing Co., Inc.},
	title = {The Unified Software Development Process},
	year = {1999}}

@inproceedings{Jameson1994,
	author = {Jameson, David H},
	booktitle = {SANTA FE INSTITUTE STUDIES IN THE SCIENCES OF COMPLEXITY-PROCEEDINGS VOLUME-},
	organization = {ADDISON-WESLEY PUBLISHING CO},
	pages = {253--253},
	title = {Sonnet: Audio-enhanced monitoring and debugging},
	volume = {18},
	year = {1994}}

@inproceedings{Kalliamvakou2014,
	abstract = {With over 10 million git repositories, GitHub is becoming one of the most important source of software artifacts on the Internet. Researchers are starting to mine the information stored in GitHub's event logs, trying to understand how its users employ the site to collaborate on software. However, so far there have been no studies describing the quality and properties of the data available from GitHub. We document the results of an empirical study aimed at understanding the characteristics of the repositories in GitHub and how users take advantage of GitHub's main features---namely commits, pull requests, and issues. Our results indicate that, while GitHub is a rich source of data on software development, mining GitHub for research purposes should take various potential perils into consideration. We show, for example, that the majority of the projects are personal and inactive; that GitHub is also being used for free storage and as a Web hosting service; and that almost 40% of all pull requests do not appear as merged, even though they were. We provide a set of recommendations for software engineering researchers on how to approach the data in GitHub.},
	address = {New York, NY, USA},
	author = {Kalliamvakou, Eirini and Gousios, Georgios and Blincoe, Kelly and Singer, Leif and German, Daniel M. and Damian, Daniela},
	booktitle = {Proceedings of the 11th Working Conference on Mining Software Repositories},
	doi = {10.1145/2597073.2597074},
	isbn = {9781450328630},
	keywords = {bias, code reviews, github, git, Mining software repositories},
	location = {Hyderabad, India},
	numpages = {10},
	pages = {92--101},
	publisher = {Association for Computing Machinery},
	series = {MSR 2014},
	title = {The Promises and Perils of Mining GitHub},
	url = {https://doi.org/10.1145/2597073.2597074},
	year = {2014},
	bdsk-url-1 = {https://doi.org/10.1145/2597073.2597074}}

@inproceedings{Kapec2015,
	author = {Kapec, P. and Brndiarov{\'a}, G. and Gloger, M. and Mar{\'a}k, J.},
	booktitle = {2015 IEEE 19th International Conference on Intelligent Engineering Systems (INES)},
	doi = {10.1109/INES.2015.7329727},
	pages = {307-312},
	title = {Visual analysis of software systems in virtual and augmented reality},
	year = {2015},
	bdsk-url-1 = {https://doi.org/10.1109/INES.2015.7329727}}

@inproceedings{Khaloo2017,
	author = {Khaloo, Pooya and Maghoumi, Mehran and Taranta, Eugene and Bettner, David and Laviola, Joseph},
	booktitle = {2017 IEEE Working Conference on Software Visualization (VISSOFT)},
	doi = {10.1109/VISSOFT.2017.10},
	pages = {43-53},
	title = {Code Park: A New 3D Code Visualization Tool},
	year = {2017},
	bdsk-url-1 = {https://doi.org/10.1109/VISSOFT.2017.10}}

@inproceedings{Knight2000,
	author = {Knight, C. and Munro, M.},
	booktitle = {2000 IEEE Conference on Information Visualization. An International Conference on Computer Visualization and Graphics},
	doi = {10.1109/IV.2000.859756},
	pages = {198-205},
	title = {Virtual but visible software},
	year = {2000},
	bdsk-url-1 = {https://doi.org/10.1109/IV.2000.859756}}

@article{Knuth1963,
	abstract = {To meet the need for improved documentation of written computer programs, a simple system for effective communication is presented, which has shown great promise. The programmer describes his program in a simple format, and the computer prepares flow charts and other cross-referenced listings from this input. The description can be kept up-to-date easily, and the final output clearly explains the original program. The system has also proved to be a valuable debugging and coding aid.},
	address = {New York, NY, USA},
	author = {Knuth, Donald E.},
	doi = {10.1145/367593.367620},
	issn = {0001-0782},
	issue_date = {Sept. 1963},
	journal = {Commun. ACM},
	month = {sep},
	number = {9},
	numpages = {9},
	pages = {555--563},
	publisher = {Association for Computing Machinery},
	title = {Computer-Drawn Flowcharts},
	url = {https://doi.org/10.1145/367593.367620},
	volume = {6},
	year = {1963},
	bdsk-url-1 = {https://doi.org/10.1145/367593.367620}}

@inproceedings{Langelier2005,
	abstract = {We propose an approach for complex software analysis based on visualization. Our work is motivated by the fact that in spite of years of research and practice, software development and maintenance are still time and resource consuming, and high-risk activities. The most important reason in our opinion is the complexity of many phenomena related to software, such as its evolution and its reliability. In fact, there is very little theory explaining them. Today, we have a unique opportunity to empirically study these phenomena, thanks to large sets of software data available through open-source programs and open repositories. Automatic analysis techniques, such as statistics and machine learning, are usually limited when studying phenomena with unknown or poorly-understood influence factors. We claim that hybrid techniques that combine automatic analysis with human expertise through visualization are excellent alternatives to them. In this paper, we propose a visualization framework that supports quality analysis of large-scale software systems. We circumvent the problem of size by exploiting perception capabilities of the human visual system.},
	address = {New York, NY, USA},
	author = {Langelier, Guillaume and Sahraoui, Houari and Poulin, Pierre},
	booktitle = {Proceedings of the 20th IEEE/ACM International Conference on Automated Software Engineering},
	doi = {10.1145/1101908.1101941},
	isbn = {1581139934},
	keywords = {software visualization, metrics, quality assessment},
	location = {Long Beach, CA, USA},
	numpages = {10},
	pages = {214--223},
	publisher = {Association for Computing Machinery},
	series = {ASE '05},
	title = {Visualization-Based Analysis of Quality for Large-Scale Software Systems},
	url = {https://doi.org/10.1145/1101908.1101941},
	year = {2005},
	bdsk-url-1 = {https://doi.org/10.1145/1101908.1101941}}

@inproceedings{Lanza2001,
	abstract = {One of the major problems in software evolution is coping with the complexity which stems from the huge amount of data that must be considered. The current approaches to deal with that problem all aim at a reduction of complexity and a filtering of the relevant information. In this paper we propose an approach based on a combination of software visualization and software metrics which we have already successfully applied in the field of software reverse engineering. Using this approach we discuss a simple and effective way to visualize the evolution of software systems which helps to recover the evolution of object oriented software systems.},
	address = {New York, NY, USA},
	author = {Lanza, Michele},
	booktitle = {Proceedings of the 4th International Workshop on Principles of Software Evolution},
	doi = {10.1145/602461.602467},
	isbn = {1581135084},
	keywords = {software visualization, reverse engineering, software metrics},
	location = {Vienna, Austria},
	numpages = {6},
	pages = {37--42},
	publisher = {Association for Computing Machinery},
	series = {IWPSE '01},
	title = {The Evolution Matrix: Recovering Software Evolution Using Software Visualization Techniques},
	url = {https://doi.org/10.1145/602461.602467},
	year = {2001},
	bdsk-url-1 = {https://doi.org/10.1145/602461.602467}}

@misc{Lanza2003,
	author = {Michele Lanza},
	title = {Object-Oriented Reverse Engineering Coarse-grained, Fine-grained, and Evolutionary Software Visualization},
	year = {2003}}

@book{Lehman1985,
	address = {USA},
	author = {Lehman, M. M. and Belady, L. A.},
	isbn = {0124424406},
	publisher = {Academic Press Professional, Inc.},
	title = {Program Evolution: Processes of Software Change},
	year = {1985}}

@article{LopezHerrejon2018,
	author = {Lopez-Herrejon, Roberto Erick and Illescas, Sheny and Egyed, Alexander},
	journal = {Journal of software: evolution and process},
	number = {2},
	pages = {e1912},
	publisher = {Wiley Online Library},
	title = {A systematic mapping study of information visualization for software product line engineering},
	volume = {30},
	year = {2018}}

@inproceedings{Mancino2017,
	author = {Mancino, Andrea and Scanniello, Giuseppe},
	booktitle = {2017 21st International Conference Information Visualisation (IV)},
	doi = {10.1109/iV.2017.28},
	pages = {127-132},
	title = {Software Musification},
	year = {2017},
	bdsk-url-1 = {https://doi.org/10.1109/iV.2017.28}}

@inproceedings{McIntosh2014,
	author = {McIntosh, Shane and Legere, Katie and Hassan, Ahmed E.},
	booktitle = {2014 Software Evolution Week - IEEE Conference on Software Maintenance, Reengineering, and Reverse Engineering (CSMR-WCRE)},
	doi = {10.1109/CSMR-WCRE.2014.6747192},
	pages = {348-352},
	title = {Orchestrating change: An artistic representation of software evolution},
	year = {2014},
	bdsk-url-1 = {https://doi.org/10.1109/CSMR-WCRE.2014.6747192}}

@inproceedings{Merino2017,
	author = {Merino, Leonel and Ghafari, Mohammad and Anslow, Craig and Nierstrasz, Oscar},
	booktitle = {2017 IEEE International Conference on Software Maintenance and Evolution (ICSME)},
	doi = {10.1109/ICSME.2017.70},
	pages = {633-637},
	title = {CityVR: Gameful Software Visualization},
	year = {2017},
	bdsk-url-1 = {https://doi.org/10.1109/ICSME.2017.70}}

@inproceedings{Merino2018,
	author = {Merino, Leonel and Bergel, Alexandre and Nierstrasz, Oscar},
	doi = {10.1109/VISSOFT.2018.00014},
	month = {09},
	title = {Overcoming Issues of {3D} Software Visualization through Immersive Augmented Reality},
	year = {2018},
	bdsk-url-1 = {https://doi.org/10.1109/VISSOFT.2018.00014}}

@article{Merino2018a,
	abstract = {Context:Software visualizations can help developers to analyze multiple aspects of complex software systems, but their effectiveness is often uncertain due to the lack of evaluation guidelines. Objective: We identify common problems in the evaluation of software visualizations with the goal of formulating guidelines to improve future evaluations. Method:We review the complete literature body of 387 full papers published in the SOFTVIS/VISSOFT conferences, and study 181 of those from which we could extract evaluation strategies, data collection methods, and other aspects of the evaluation. Results:Of the proposed software visualization approaches, 62% lack a strong evaluation. We argue that an effective software visualization should not only boost time and correctness but also recollection, usability, engagement, and other emotions. Conclusion:We call on researchers proposing new software visualizations to provide evidence of their effectiveness by conducting thorough (i) case studies for approaches that must be studied in situ, and when variables can be controlled, (ii) experiments with randomly selected participants of the target audience and real-world open source software systems to promote reproducibility and replicability. We present guidelines to increase the evidence of the effectiveness of software visualization approaches, thus improving their adoption rate.},
	author = {L. Merino and M. Ghafari and C. Anslow and O. Nierstrasz},
	doi = {https://doi.org/10.1016/j.jss.2018.06.027},
	issn = {0164-1212},
	journal = {Journal of Systems and Software},
	keywords = {Software visualisation, Evaluation, Literature review},
	pages = {165-180},
	title = {A systematic literature review of software visualization evaluation},
	url = {https://www.sciencedirect.com/science/article/pii/S0164121218301237},
	volume = {144},
	year = {2018},
	bdsk-url-1 = {https://www.sciencedirect.com/science/article/pii/S0164121218301237},
	bdsk-url-2 = {https://doi.org/10.1016/j.jss.2018.06.027}}

@inproceedings{Mueller1988,
	abstract = {This paper describes Rigi, a model and a tool for programming-in-the-large. Rigi uses a graph model and abstraction mechanisms to structure and represent the information accumulated during the development process. The objects and relationships of the graph model represent system components and their dependencies. The objects can be arranged in aggregation and generalization hierarchies. The Rigi editor assists the designers, programmers, integrators, and maintainers in defining, manipulating, exploring, and understanding, the structure of large, integrated, evolving software systems. Rigi was designed to address three of the most difficult problems in the area of programming-in-the-large: the mastery of the structural complexity of large software systems, the effective presentation of development information, and the definition of procedures for checking and maintaining the completeness, consistency, and traceability of system descriptions. Thus, the major objective of Rigi is to effectively represent and manipulate the building blocks of a software system and their myriad dependencies, thereby aiding the development phases of the project.},
	address = {Washington, DC, USA},
	author = {M\"{u}ller, H. A. and Klashinsky, K.},
	booktitle = {Proceedings of the 10th International Conference on Software Engineering},
	isbn = {0897912586},
	location = {Singapore},
	numpages = {7},
	pages = {80--86},
	publisher = {IEEE Computer Society Press},
	series = {ICSE '88},
	title = {Rigi-A System for Programming-in-the-Large},
	year = {1988}}

@article{Nassi1973,
	abstract = {With the advent of structured programming and GOTO-less programming a method is needed to model computation in simply ordered structures, each representing a complete thought possibly defined in terms of other thoughts as yet undefined. A model is needed which prevents unrestricted transfers of control and has a control structure closer to languages amenable to structured programming. We present an attempt at such a model.},
	address = {New York, NY, USA},
	author = {Nassi, I. and Shneiderman, B.},
	doi = {10.1145/953349.953350},
	issn = {0362-1340},
	issue_date = {August 1973},
	journal = {SIGPLAN Not.},
	month = {aug},
	number = {8},
	numpages = {15},
	pages = {12--26},
	publisher = {Association for Computing Machinery},
	title = {Flowchart Techniques for Structured Programming},
	url = {https://doi.org/10.1145/953349.953350},
	volume = {8},
	year = {1973},
	bdsk-url-1 = {https://doi.org/10.1145/953349.953350}}

@inproceedings{Panas2007,
	author = {Panas, Thomas and Epperly, Thomas and Quinlan, Daniel and Saebjornsen, Andreas and Vuduc, Richard},
	booktitle = {12th IEEE International Conference on Engineering Complex Computer Systems (ICECCS 2007)},
	organization = {IEEE},
	pages = {217--228},
	title = {Communicating software architecture using a unified single-view visualization},
	year = {2007}}

@inproceedings{Pinzger2005,
	abstract = {Observing the evolution of very large software systems needs the analysis of large complex data models and visualization of condensed views on the system. For visualization software metrics have been used to compute such condensed views. However, current techniques concentrate on visualizing data of one particular release providing only insufficient support for visualizing data of several releases.In this paper we present the RelVis visualization approach that concentrates on providing integrated condensed graphical views on source code and release history data of up to n releases. Measures of metrics of source code entities and relationships are composed in Kiviat diagrams as annual rings. Diagrams highlight the good and bad times of an entity and facilitate the identification of entities and relationships with critical trends. They represent potential refactoring candidates that should be addressed first before further evolving the system. The paper provides needed background information and evaluation of the approach with a large open source software project.},
	address = {New York, NY, USA},
	author = {Pinzger, Martin and Gall, Harald and Fischer, Michael and Lanza, Michele},
	booktitle = {Proceedings of the 2005 ACM Symposium on Software Visualization},
	doi = {10.1145/1056018.1056027},
	isbn = {1595930736},
	keywords = {Kiviat, software evolution analysis, software visualization, evolution metrics},
	location = {St. Louis, Missouri},
	numpages = {9},
	pages = {67--75},
	publisher = {Association for Computing Machinery},
	series = {SoftVis '05},
	title = {Visualizing Multiple Evolution Metrics},
	url = {https://doi.org/10.1145/1056018.1056027},
	year = {2005},
	bdsk-url-1 = {https://doi.org/10.1145/1056018.1056027}}

@inproceedings{Ratzinger2005,
	author = {Ratzinger, J. and Fischer, M. and Gall, H.},
	booktitle = {Eighth International Workshop on Principles of Software Evolution (IWPSE'05)},
	doi = {10.1109/IWPSE.2005.16},
	pages = {103-112},
	title = {EvoLens: lens-view visualizations of evolution data},
	year = {2005},
	bdsk-url-1 = {https://doi.org/10.1109/IWPSE.2005.16}}

@article{Salis2019,
	abstract = {Empirical software engineering work often involves studying revision control system repositories maintained using the popular Git system. Checking out each revision one wants to study is inefficient. On the other hand the examination of directories and files of past revisions using Git's commands suffers from a usability perspective. We introduce repofs, a tool that exposes a Git repository as a virtual user-level file system. Commits, branches, and tags appear as separate directory trees allowing them to be efficiently processed through command-line tools and file explorers. We illustrate these points through motivating examples and discuss the advantages and drawbacks of the proposed approach.},
	author = {Vitalis Salis and Diomidis Spinellis},
	doi = {https://doi.org/10.1016/j.softx.2019.03.007},
	issn = {2352-7110},
	journal = {SoftwareX},
	keywords = {Git, Virtual file system, Mining software repositories, Unix shell},
	pages = {288-292},
	title = {RepoFS: File system view of Git repositories},
	url = {https://www.sciencedirect.com/science/article/pii/S2352711018300712},
	volume = {9},
	year = {2019},
	bdsk-url-1 = {https://www.sciencedirect.com/science/article/pii/S2352711018300712},
	bdsk-url-2 = {https://doi.org/10.1016/j.softx.2019.03.007}}

@inproceedings{Schneider2016,
	author = {Schneider, Teseo and Tymchuk, Yuriy and Salgado, Ronie and Bergel, Alexandre},
	booktitle = {2016 IEEE Working Conference on Software Visualization (VISSOFT)},
	doi = {10.1109/VISSOFT.2016.17},
	pages = {116-125},
	title = {CuboidMatrix: Exploring Dynamic Structural Connections in Software Components Using Space-Time Cube},
	year = {2016},
	bdsk-url-1 = {https://doi.org/10.1109/VISSOFT.2016.17}}

@book{seacord2003,
	abstract = {From the Book: Software systems become legacy systems when they begin to resist modification and evolution. However, the knowledge embodied in legacy systems constitutes significant corporate assets. Assuming these system still provide significant business value, they must then be modernized or replaced. This book describes a risk-managed approach to legacy system modernization that applies a knowledge of software technologies and an understanding of engineering processes within a business context. Audience Modernizing Legacy Systems: Software Technologies, Engineering Processes and Business Practices should be useful to anyone involved in modernizing a legacy system. As a software engineer, it should help you understand some of the larger business concerns that drive a modernization effort. As a software designer, this book should help you understand the impact of legacy code, coupled with incremental development and deployment practices, on design activities. As a system architect, this book explains the processes and techniques that have failed or succeeded in practice. It should also provide insight into how you can repeat these successes and avoid the failures. As an IT manager, this book explains how technology and business objectives influence the software modernization processes. In particular, it should help you answer the following questions: When and how do I decide if a modernization or replacement effort is justified How do I develop an understanding of the legacy system How do I gain an understanding of, and evaluate the applicability of, infsystem technologies that can be used in the modernization of my system When do I involve the stakeholders and how can I reconcile their conflicting needs What role does architecture play in legacy system modernization How can I estimate the cost of a legacy system modernization How can I evaluate and select a modernization strategy How can I develop a detailed modernization plan Organization and Content Modernizing Legacy Systems: Software Technologies, Engineering Processes and Business Practices shows how legacy systems can be incrementally modernized. It uses and extends the methods and techniques described in Building Systems from Commercial Components Wallnau, 2001 to draw upon engineering expertise early in the conceptual phase to ensure realistic and comprehensive planning. This book features an extensive case study involving a major modernization effort. The legacy system in this case study consists of nearly 2 million lines of COBOL code developed over 30 years. The system is being replaced with a modern system based on the Java 2 Enterprise Edition (J2EE) architecture. Additional challenges include a requirement to incrementally develop and deploy the system. We look at the strategy used to modernize the system; the use of Enterprise JavaBeans, message-oriented middleware, Java, and other J2EE technologies to produce the modern system; the supporting software engineering processes and techniques; and the resulting system. Chapters 1 of this book provides an introduction to the challenges and practices of software evolution and Chapter 2 introduces the major case study in the bo introduces the Risk-Managed Modernization (RMM) approach which is elaborated in Chapters 4 through 17 and illustrated by the case study. Throughout Chapters 4 through 17 we provide an activity diagram of RMM as a road map to each chapter. Chapter 18 provides some recommendations to help guide your modernization efforts (although these recommendations cannot be fully appreciated without reading the main body of the book).Throughout this book we use the Unified Modelling Language (UML) to represent architecture drawings and design patterns. A brief introduction to UML is provided in Chapter 6.},
	address = {USA},
	author = {Seacord, Robert C. and Plakosh, Daniel and Lewis, Grace A.},
	isbn = {0321118847},
	publisher = {Addison-Wesley Longman Publishing Co., Inc.},
	title = {Modernizing Legacy Systems: Software Technologies, Engineering Process and Business Practices},
	year = {2003}}

@book{SoftwareEvolution,
	abstract = {Software has become omnipresent and vital in our information-based society, so all software producers should assume responsibility for its reliability. While 'reliable' originally assumed implementations that were effective and mainly error-free, additional issues like adaptability and maintainability have gained equal importance recently. For example, the 2004 ACM/IEEE Software Engineering Curriculum Guidelines list software evolution as one of ten key areas of software engineering education. Mens and Demeyer, both international authorities in the field of software evolution, together with the invited contributors, focus on novel trends in software evolution research and its relations with other emerging disciplines such as model-driven software engineering, service-oriented software development, and aspect-oriented software development. They do not restrict themselves to the evolution of source code but also address the evolution of other, equally important software artifacts such as databases and database schemas, design models, software architectures, and process management. The contributing authors provide broad overviews of related work, and they also contribute to a comprehensive glossary, a list of acronyms, and a list of books, journals, websites, standards and conferences that together represent the community's body of knowledge. Combining all these features, this book is the indispensable source for researchers and professionals looking for an introduction and comprehensive overview of the state of the art. In addition, it is an ideal basis for an advanced course on software evolution.},
	address = {Berlin},
	author = {Tom Mens, Serge Demeye},
	isbn = {9783540764397},
	keywords = {Logiciels},
	language = {eng},
	publisher = {Springer},
	title = {Software evolution},
	year = {2008}}

@book{Sommerville1995,
	address = {USA},
	author = {Sommerville, Ian},
	isbn = {0201427656},
	publisher = {Addison Wesley Longman Publishing Co., Inc.},
	title = {Software Engineering (5th Ed.)},
	year = {1995}}

@inproceedings{Sonnenwald1990,
	author = {Sonnenwald, D.H. and Gopinath, B. and Haberman, G.O. and Keese, W.M. and Myers, J.S.},
	booktitle = {Twenty-Third Annual Hawaii International Conference on System Sciences},
	doi = {10.1109/HICSS.1990.205229},
	pages = {541-546 vol.2},
	title = {InfoSound: an audio aid to program comprehension},
	volume = {2},
	year = {1990},
	bdsk-url-1 = {https://doi.org/10.1109/HICSS.1990.205229}}

@inproceedings{Spadini2018,
	abstract = {Software repositories contain historical and valuable information about the overall development of software systems. Mining software repositories (MSR) is nowadays considered one of the most interesting growing fields within software engineering. MSR focuses on extracting and analyzing data available in software repositories to uncover interesting, useful, and actionable information about the system. Even though MSR plays an important role in software engineering research, few tools have been created and made public to support developers in extracting information from Git repository. In this paper, we present PyDriller, a Python Framework that eases the process of mining Git. We compare our tool against the state-of-the-art Python Framework GitPython, demonstrating that PyDriller can achieve the same results with, on average, 50% less LOC and significantly lower complexity.  URL: https://github.com/ishepard/pydriller  Materials: https://doi.org/10.5281/zenodo.1327363  Pre-print: https://doi.org/10.5281/zenodo.1327411},
	address = {New York, NY, USA},
	author = {Spadini, Davide and Aniche, Maur\'{\i}cio and Bacchelli, Alberto},
	booktitle = {Proceedings of the 2018 26th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
	doi = {10.1145/3236024.3264598},
	isbn = {9781450355735},
	keywords = {Mining Software Repositories, GitPython, Python, Git},
	location = {Lake Buena Vista, FL, USA},
	numpages = {4},
	pages = {908--911},
	publisher = {Association for Computing Machinery},
	series = {ESEC/FSE 2018},
	title = {PyDriller: Python Framework for Mining Software Repositories},
	url = {https://doi.org/10.1145/3236024.3264598},
	year = {2018},
	bdsk-url-1 = {https://doi.org/10.1145/3236024.3264598}}

@inbook{Stasko2008,
	author = {Fekete, Jean-Daniel and van Wijk, Jarke and Stasko, John and North, Chris},
	doi = {10.1007/978-3-540-70956-5_1},
	isbn = {978-3-540-70955-8},
	month = {07},
	pages = {1-18},
	publisher = {Springer Berlin, Heidelberg},
	title = {The Value of Information Visualization},
	volume = {4950},
	year = {2008},
	bdsk-url-1 = {https://doi.org/10.1007/978-3-540-70956-5_1}}

@inproceedings{Steinbrueckner2010,
	abstract = {In this paper we describe a systematic approach to utilize the city metaphor for the visualization of large software systems as evolving software cities. The main contribution is a new layout approach which explicitly takes the development history of software systems into account and makes history directly visible in the layouts. These layouts incrementally evolve in a very smooth and stable way during the development of the represented software system. They are used as a visualization platform for integrating a large variety of product and process data and thus create a coherent set of specialized visualizations. To illustrate this we present some example maps capturing specific development history aspects.},
	address = {New York, NY, USA},
	author = {Steinbr\"{u}ckner, Frank and Lewerentz, Claus},
	booktitle = {Proceedings of the 5th International Symposium on Software Visualization},
	doi = {10.1145/1879211.1879239},
	isbn = {9781450300285},
	keywords = {software landscapes, software cities, software visualization, software evolution},
	location = {Salt Lake City, Utah, USA},
	numpages = {10},
	pages = {193--202},
	publisher = {Association for Computing Machinery},
	series = {SOFTVIS '10},
	title = {Representing Development History in Software Cities},
	url = {https://doi.org/10.1145/1879211.1879239},
	year = {2010},
	bdsk-url-1 = {https://doi.org/10.1145/1879211.1879239}}

@inproceedings{Taylor2002,
	abstract = {The use and development of open source software has increased significantly within the last decade. With it has come an increased, and necessary, use of version control tools to provide project management. A typical repository contains a mine of information that is not always obvious, and not easy to comprehend in its plain form. A visualisation has been created from this information to display how the repository has evolved. The visualisation allows the user to see where the active areas of the project are, how often, and how, changes are made, andhow work is shared out across the project. Colour, layout and animation are all important features of the visualisation. In addition, issues of the importance and use of animation and consistency are raised. A prototype tool has also been developed to show how the visualisation works in practice.},
	address = {USA},
	author = {Taylor, Christopher M. B. and Munro, Malcolm},
	booktitle = {Proceedings of the 1st International Workshop on Visualizing Software for Understanding and Analysis},
	isbn = {0769516629},
	pages = {43},
	publisher = {IEEE Computer Society},
	series = {VISSOFT '02},
	title = {Revision Towers},
	year = {2002}}

@article{Vickers2003,
	abstract = {Program execution behavior can be mapped to a structured musical framework that helps locate and diagnose software errors.},
	address = {New York, NY, USA},
	author = {Vickers, Paul and Alty, James L.},
	doi = {10.1145/792704.792734},
	issn = {0001-0782},
	issue_date = {July 2003},
	journal = {Commun. ACM},
	month = {jul},
	number = {7},
	numpages = {8},
	pages = {86--93},
	publisher = {Association for Computing Machinery},
	title = {Siren Songs and Swan Songs Debugging with Music},
	url = {https://doi.org/10.1145/792704.792734},
	volume = {46},
	year = {2003},
	bdsk-url-1 = {https://doi.org/10.1145/792704.792734}}

@inproceedings{Vickers2004,
	author = {Vickers, Paul},
	booktitle = {ICAD 2004},
	month = {01},
	title = {External Auditory Representations of Programs: Past, Present, and Future an Aesthetic Perspective.},
	year = {2004}}

@article{VonMayrhauser1995,
	author = {Von Mayrhauser, A. and Vans, A.M.},
	doi = {10.1109/2.402076},
	journal = {Computer},
	number = {8},
	pages = {44-55},
	title = {Program comprehension during software maintenance and evolution},
	volume = {28},
	year = {1995},
	bdsk-url-1 = {https://doi.org/10.1109/2.402076}}

@article{Waters1983,
	address = {New York, NY, USA},
	author = {Waters, Richard C.},
	doi = {10.1145/69575.357225},
	issn = {0164-0925},
	issue_date = {Oct. 1983},
	journal = {ACM Trans. Program. Lang. Syst.},
	month = {oct},
	number = {4},
	numpages = {19},
	pages = {513--531},
	publisher = {Association for Computing Machinery},
	title = {User Format Control in a LISP Prettyprinter},
	url = {https://doi.org/10.1145/69575.357225},
	volume = {5},
	year = {1983},
	bdsk-url-1 = {https://doi.org/10.1145/69575.357225}}

@inproceedings{Wettel2007,
	author = {Wettel, Richard and Lanza, Michele},
	booktitle = {2007 4th IEEE International Workshop on Visualizing Software for Understanding and Analysis},
	doi = {10.1109/VISSOF.2007.4290706},
	pages = {92-99},
	title = {Visualizing Software Systems as Cities},
	year = {2007},
	bdsk-url-1 = {https://doi.org/10.1109/VISSOF.2007.4290706}}

@inproceedings{Wettel2011,
	author = {Wettel, Richard and Lanza, Michele and Robbes, Romain},
	booktitle = {2011 33rd International Conference on Software Engineering (ICSE)},
	doi = {10.1145/1985793.1985868},
	pages = {551-560},
	title = {Software systems as cities: a controlled experiment},
	year = {2011},
	bdsk-url-1 = {https://doi.org/10.1145/1985793.1985868}}

@inproceedings{Young1998,
	author = {Young, P. and Munro, M.},
	booktitle = {Proceedings. 6th International Workshop on Program Comprehension. IWPC'98 (Cat. No.98TB100242)},
	doi = {10.1109/WPC.1998.693276},
	pages = {19-26},
	title = {Visualising software in virtual reality},
	year = {1998},
	bdsk-url-1 = {https://doi.org/10.1109/WPC.1998.693276}}

@book{Dijkstra1971a,
	author = {Dijkstra, Edsger Wybe},
	publisher = {Technische Hogeschool},
	title = {Ewd316: A short introduction to the art of programming},
	year = {1971}}

@inproceedings{DiGiano1992,
	author = {Chris DiGiano and Ronald M. Baecker},
	booktitle = {Program auralization: sound enhancements to the programming environment},
	title = {Program auralization: sound enhancements to the programming environment},
	year = {1992}}

@Article{kleiner1993,
  author  = {Kleiner, Mendel and dalenb{\"a}ck, bengt-inge and svensson, peter},
  journal = {journal of the audio engineering society},
  title   = {auralization-an overview},
  year    = {1993},
  month   = {november},
  number  = {11},
  pages   = {861-875},
  volume  = {41},
}

@Comment{jabref-meta: databaseType:bibtex;}
